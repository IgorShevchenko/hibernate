Info for Chapter 4:

- Hibernate is for fine-grained and rich Java domain models
- More classes than tables
- Classes have identity and lifecycle

Entity type:
- own identity
- independent lifecycle
- also many-to-one associations
- also dependent life cycle, but has shared references

Value type:
- embeddable classes
- bound to the owning entity instance
- shouldn't have shared references

Keep an eye on:
- shared runtime references
- avoid shared references to value types
- life cycle dependencies require cascading delete rules
- make everything a value typed class and promote it to an entity
- instead of mapping collections, write queries to obtain them

Identity:
- primary key, configure key generators, identifier generator strategies
- object identity: ==
- object equality: equals
- database identity: the same table and primary key value

<delimited-identifiers>


Mentions:
- Item, Category, User, Address, Address.setItem()
- USERS
- model/package-info.java




DO READ:


You also need an @Id annotation,
Every entity class has to have an @Id property;
if @Id is on a field, the JPA provider will access fields of the class directly and
consider all fields part of the persistent state by default.
more freedom for accessor method design
shouldn’t expose a public identifier setter method on an entity.

A candidate key is a column or set of columns that you could use to identify a particular
row in a table.
- The value is never null
- is a unique value for any row
- Value never changes; it’s immutable.

candidate key must be unique and irreducible (no subset of the key attributes has the uniqueness property)

Hibernate expects a candidate key to be immutable when used as the primary key. 
Hibernate doesn’t support updating primary key values with an API; 
if you try to work around this requirement, you’ll run into problems with Hibernate’s caching and dirty-checking engine.

SQL query can update primary key column
you choose between candidate keys to decide the best primary key for the table

A natural key is a key with business meaning: 
an attribute or combination of attributes that is unique by virtue of its business semantics.

A good primary key must be unique, immutable, and never null.
natural candidate keys by combining several columns in a composite natural key.
Surrogate keys have no business meaning—they have unique values generated by the database or application
(almost) every table in your schema should have a dedicated surrogate primary key column with only this purpose.

Without @GeneratedValue, the JPA provider assumes that you’ll take care of
creating and assigning an identifier value before you save an instance.
Necessary when you’re dealing with a legacy database and/or natural primary keys.

GenerationType.AUTO—Hibernate picks an appropriate strategy, asking the SQL dialect of your configured database what is best.

GenerationType.SEQUENCE—Hibernate expects a sequence named HIBERNATE_SEQUENCE in your database. The sequence
will be called separately before every INSERT, producing sequential numeric values.

GenerationType.IDENTITY—Hibernate expects (and creates in table DDL) a special auto-incremented primary 
key column that automatically generates a numeric value on INSERT, in the database.

GenerationType.TABLE—Hibernate will use an extra table in your database schema that holds the next numeric primary key value, 
one row for each entity class. This table will be read and updated accordingly, before INSERTs. The default table name is 
HIBERNATE_SEQUENCES with columns SEQUENCE_NAME and SEQUENCE_NEXT_HI_VALUE.

Should explicitly configure a primary key generation strategy.

JPA has two built-in annotations you can use to configure named generators: 
@javax.persistence.SequenceGenerator and @javax.persistence.TableGenerator. 
With these annotations, you can create a named generator with your own sequence and table names.

native @org.hibernate.annotations.GenericGenerator annotation
It supports all Hibernate identifier generator strategies and their configuration details.

The enhanced-sequence B strategy produces sequential numeric values. If
your SQL dialect supports sequences, Hibernate will use an actual database
sequence. If your DBMS doesn’t support native sequences, Hibernate will manage
and use an extra “sequence table,” simulating the behavior of a sequence.

You can share the same database sequence among all your domain model classes.
It doesn’t matter if primary key values aren’t contiguous for a particular entity, as long as they’re unique within one table.

item that hasn’t been stored in the database: either null or 0. If you want to test
whether an item is new, a null check is probably easier to understand

You shouldn’t use another integral type such as int or short for identifiers.







