Info for Chapter 5:

- Mapping basic properties
- Mapping embeddable components
- Controlling mapping between Java and SQL types

basic value-typed classes that come with the JDK, such as String, Date, primitives, and their wrappers
developer defined value-typed classes, such as Address and MonetaryAmount

overriding defaults, customizing access, and generated values.
SQL is used with derived properties and transformed column values.
We wrap up basic properties with temporal properties and mapping enumerations.
We then discuss custom value-typed classes and map them as embeddable components. 
You learn how classes relate to the database schema and make your classes embeddable,
while allowing for overriding embedded attributes. We complete embeddable
components by mapping nested components. Finally, we discuss how to customize
loading and storing of property values at a lower level with flexible JPA converters.

Converter API for basic-typed attributes, so you can control how
values are loaded and stored and transform them if necessary.

All of entity (or embeddable type) 's properties are considered persistent by default.
Hibernate loads and stores the value of the property in a column with an appropriate SQL type and the same name as the property.

Otherwise, if the type of the property is java.io.Serializable, its value is stored in its serialized form. 
This typically isn’t what you want, and you should always map Java classes instead of storing a heap of bytes in the database.

Otherwise, Hibernate will throw an exception on startup, complaining that it doesn’t understand the type of the property.
This configuration by exception approach means you don’t have to annotate a property to
make it persistent; you only have to configure the mapping in an exceptional case.

To exclude a property, mark the field or the getter method of the property with the
@javax.persistence.Transient annotation or use the Java transient keyword. 
The transient keyword usually only excludes fields for Java serialization, but it’s also recognized by JPA providers.

@Basic(optional = false)
Has two parameters: optional, marks the property as not optional at the Java object level.
By default, all persistent properties are nullable and optional; an Item may have an
unknown initialPrice. Mapping the initialPrice property as non-optional makes
sense if you have a NOT NULL constraint on the INITIALPRICE column in your SQL
schema. If Hibernate is generating the SQL schema, it will include a NOT NULL constraint
automatically for non-optional properties.

Hibernate will complain with an exception before hitting the database with an SQL
statement. Hibernate knows that a value is required to perform an INSERT or UPDATE.
If you don’t mark the property as optional and try to save a NULL, the database will
reject the SQL statement, and Hibernate will throw a constraint-violation exception.
There isn’t much difference in the end result, but it’s cleaner to avoid hitting the database
with a statement that fails.

@Column(nullable = false)
Instead of @Basic, most engineers use the more versatile @Column annotation to declare nullability.

Three ways to declare whether a property value is required: 
1) @Basic(optional = false)
2) @Column(nullable = false) 
3) @NotNull Bean Validation
All have the same effect on the JPA provider: Hibernate does a null check when saving, 
and generates a NOT NULL constraint in the database schema. 
org.hibernate.PropertyValueException:
Insert is always executed for @Basic(optional = false) and @Column(nullable = false),
if bean validation is enabled. Then it relies only on @NotNull.

We recommend the Bean Validation @NotNull annotation so you can manually validate an Item instance 
and/or have your user interface code in the presentation layer execute validation checks automatically.

The persistence engine accesses the properties of a class either directly through fields or indirectly through 
getter and setter methods. An annotated entity inherits the default from the position of the mandatory @Id annotation.
Annotations are never on the setter methods.

Any @Embedded class inherits the default or explicitly declared access strategy of its owning root entity class.

Hibernate accesses any @MappedSuperclass properties with the default or explicitly declared 
access strategy of the mapped entity class. Inherits mapped columns. Can override.

Use @Access annotation for overriding the default behavior, with the parameters AccessType.FIELD and 
AccessType.PROPERTY. If you set @Access on the class/entity level, Hibernate accesses all properties of 
the class according to the selected strategy. You can also use the @Access annotation to override the 
access strategy of individual properties. Annotations will be considered only if they placed according to 
access strategy. When overriding access, annotations must be on the same element as @Access annotation.

=> RARELY USED EXTENSION START
The noop property accessor. It lets you refer to a virtual property in queries. This is useful if you 
have a database column you’d like to use only in JPA queries. Domain model does not define it.
It might be a legacy column or a column maintained by another application or database trigger. 
The only way to map such a virtual property is with an hbm.xml native metadata file. 
Remember that such a native mapping file has to be complete!

If none of the built-in access strategies are appropriate, you can define your own customized property-access strategy 
by implementing the interface org.hibernate.property.PropertyAccessor. You enable a custom accessor by setting its fully qualified
name in a Hibernate extension annotation: @org.hibernate.annotations.AttributeAccessor("my.custom.Accessor").
=> END

@Formula
Some properties don’t map to a column. In particular, a derived property takes its value from an SQL expression.
Derived property is calculated at runtime by evaluating an SQL expression. 
Evaluated every time an entity is retrieved from the database and not at any other time.
The properties never appear in an SQL INSERT or UPDATE, only in SELECTs. 
Evaluation occurs in the database; Hibernate embeds the SQL formula in the SELECT clause when loading the instance.
Formulas may refer to columns, they can call SQL functions, and they may even include SQL subselects.
Notice that unqualified column names refer to columns of the table of the class to which the derived property belongs.
The database evaluates SQL expressions in formulas only when Hibernate retrieves an entity instance from the database. 

@org.hibernate.annotations.ColumnTransformer
Hibernate also supports a variation of formulas called column transformers, 
allowing you to write a custom SQL expression for reading and writing a property value.
Can convert the value of the database column when reading and writing a row.
Has a single placeholder (the question mark).
The calculation occurs in the database. SQL expression calculates the actual value to be inserted or updated.
Hibernate also applies column converters in query restrictions. WHERE weight = 10 =====> WHERE weight_pounds * 2 = 10  
Note that your database probably won’t be able to rely on an index for this restriction;
you’ll see a full table scan, because the weight for all ITEM rows has to be calculated to
evaluate the restriction.

@org.hibernate.annotations.Generated
Another special kind of property relies on database-generated values.
Examples of database-generated values are a creation timestamp, a
default price for an item, and a trigger that runs for every modification.
Whenever Hibernate issues an SQL INSERT or UPDATE for an entity that has declared generated properties, it does a
SELECT immediately afterward to retrieve the generated values for every generated property.
Available settings for GenerationTime are ALWAYS and INSERT.

ALWAYS => Hibernate refreshes the entity instance after every SQL UPDATE or INSERT. 
Assume database trigger will keep the lastModified property current. 
The property should also be marked read-only, with the updatable and insertable parameters of @Column.
Also means column is not insertable/updatable, e.g. @Column(insertable = false, updatable = false)

INSERT => refreshing only occurs after an SQL INSERT, to retrieve the default value provided by the database. 
Also means column is not insertable, e.g. @Column(insertable = false) 

@ColumnDefault 
Sets the default value of the column when Hibernate exports and generates the SQL schema DDL.
Does not make column no-nullable.

@Temporal(TemporalType.TIMESTAMP)
Timestamps are frequently automatically generated values, either by the database, or by the application. 
The JPA specification requires that you annotate temporal properties with @Temporal to declare the 
accuracy of the SQL data type of the mapped column. The Java temporal types are java.util.Date,
java.util.Calendar, java.sql.Date, java.sql.Time, and java.sql.Timestamp.
Hibernate also supports java.time package available in JDK 8. Hibernate defaults to TIMESTAMP.  
The annotation isn’t required if a converter is applied or applicable for the property.

@CreationTimestamp
Included into INSERT, column is updatable, nullable. Value set in constructor is overriden.
The property value will be set to the current VM date exactly once when saving for the first time. 

@UpdateTimestamp
Included into INSERT/UPDATE, column is updatable, nullable.
On INSERT has the same value as CreationTimestamp. 
The property value will be set to the current VM date whenever the owning entity is updated. 

You can also write and configure custom value generators, running in the application or database. 
Have a look at org.hibernate.annotations.GeneratorType and ValueGenerationType.

@Enumerated
By default, Hibernate would store the ORDINAL position of the value.
The EnumType.STRING option is a better choice; Hibernate stores the label of the enum value as is.








