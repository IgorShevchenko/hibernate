Info for Chapter 4:

- Hibernate is for fine-grained and rich Java domain models
- More classes than tables
- Classes have identity and lifecycle

Entity type:
- own identity
- independent lifecycle
- also many-to-one associations
- also dependent life cycle, but has shared references

Value type:
- embeddable classes
- bound to the owning entity instance
- shouldn't have shared references
- only one entity instance can reference it
- has no individual identity

Keep an eye on:
- shared runtime references
- avoid shared references to value types
- life cycle dependencies require cascading delete rules
- make everything a value typed class and promote it to an entity
- instead of mapping collections, write queries to obtain them

Identity:
- primary key, configure key generators, identifier generator strategies
- object identity: ==
- object equality: equals
- database identity: the same table and primary key value

<delimited-identifiers>
Hibernate then enforces quoted identifiers everywhere, write in XML only (pu-metadata.xml).
Or can quote only keywords with hibernate.auto_quote_keyword=true in your persistence unit 

Every entity class has to have an @Id property;
if @Id is on a field, the JPA provider will access fields of the class directly and
consider all fields part of the persistent state by default.
More freedom for accessor method design.
Shouldn’t expose a public identifier setter method on an entity.

A candidate key is a column or set of columns that can identify a particular row in a table.
- the value is never null
- is a unique value for any row
- value never changes; it’s immutable.
- irreducible (no subset of the key attributes has the uniqueness property)
You choose between candidate keys to decide the best primary key for the table.

Hibernate expects a candidate key to be immutable when used as the primary key. 
Hibernate doesn’t support updating primary key values with an API.
if you try to work around this requirement, you’ll run into problems with Hibernate’s caching and dirty-checking engine.
SQL query can update primary key column.

A natural key is a key with business meaning:
an attribute or combination of attributes that is unique by virtue of its business semantics.
Natural candidate keys by combining several columns in a composite natural key.

Surrogate keys have no business meaning — they have unique values generated by the database or application.
(almost) every table in your schema should have a dedicated surrogate primary key column with only this purpose.

Without @GeneratedValue, the JPA provider assumes that you’ll take care of
creating and assigning an identifier value before you save an instance.
Necessary when you’re dealing with a legacy database and/or natural primary keys.

GenerationType.AUTO — Hibernate picks an appropriate strategy, asking the SQL dialect of your configured database what is best.

GenerationType.SEQUENCE — Hibernate expects a sequence named HIBERNATE_SEQUENCE in your database. The sequence
will be called separately before every INSERT, producing sequential numeric values.

GenerationType.IDENTITY — Hibernate expects (and creates in table DDL) a special auto-incremented primary 
key column that automatically generates a numeric value on INSERT, in the database.

GenerationType.TABLE — Hibernate will use an extra table in your database schema that holds the next numeric primary key value, 
one row for each entity class. This table will be read and updated accordingly, before INSERTs. The default table name is 
HIBERNATE_SEQUENCES with columns SEQUENCE_NAME and SEQUENCE_NEXT_HI_VALUE.

Should explicitly configure a primary key generation strategy.

JPA has two built-in annotations you can use to configure named generators: 
@javax.persistence.SequenceGenerator and @javax.persistence.TableGenerator. 
With these annotations, you can create a named generator with your own sequence and table names.

Native @org.hibernate.annotations.GenericGenerator annotation
It supports all Hibernate identifier generator strategies and their configuration details.

The enhanced-sequence strategy produces sequential numeric values. If
your SQL dialect supports sequences, Hibernate will use an actual database
sequence. If your DBMS doesn’t support native sequences, Hibernate will manage
and use an extra “sequence table,” simulating the behavior of a sequence.

You can share the same database sequence among all your domain model classes.
It doesn’t matter if primary key values aren’t contiguous for a particular entity, as long as they’re unique within one table.

Item that hasn’t been stored in the database: either null or 0. If you want to test
whether an item is new, a null check is probably easier to understand.

You shouldn’t use another integral type such as int or short for identifiers.

If you require consistent portable behavior, and identifier values to be available before INSERTs, use enhanced-sequence. 
This is a portable, flexible, and modern strategy, also offering various optimizers for large datasets.

An ORM service tries to optimize SQL INSERTs: for example, by batching several at the JDBC level. 
Hence, SQL execution occurs as late as possible during a unit of work, not when you call 
entityManager.persist(someItem). This merely queues the insertion for later execution and, 
if possible, assigns the identifier value. But if you now call someItem.getId(), 
you might get null back if the engine wasn’t able to generate an identifier before the INSERT. 

In general, we prefer pre-insert generation strategies that produce identifier values 
independently, before INSERT. A common choice is a shared and concurrently accessible 
database sequence. Autoincremented columns, column default values, or 
trigger-generated keys are only available after the INSERT.

=> org.hibernate.id.enhanced.SequenceStyleGenerator
enhanced-sequence supports an org.hibernate.id.enhanced.Optimizer to 
avoid hitting the database before each INSERT; defaults to no optimization and 
fetching a new value for each INSERT. For all parameters, see the Javadoc for the
class org.hibernate.id.enhanced.SequenceStyleGenerator. Equivalent to JPA
GenerationType.SEQUENCE and GenerationType.AUTO with the New mapping
enabled, most likely your best option of the built-in strategies.

=> org.hibernate.id.enhanced.TableGenerator
enhanced-table — Uses an extra table named HIBERNATE_SEQUENCES, with one
row by default representing the sequence, storing the next value. This value is
selected and updated when an identifier value has to be generated. You can
configure this generator to use multiple rows instead: one for each generator;
see the Javadoc for org.hibernate.id.enhanced.TableGenerator. Equivalent
to JPA GenerationType.TABLE with the New mapping enabled.

increment — At Hibernate startup, reads the maximum (numeric) primary key
column value of each entity’s table and increments the value by one each time a
new row is inserted. Especially efficient if a non-clustered Hibernate application
has exclusive access to the database; but don’t use it in any other scenario.

uuid2 — Produces a unique 128-bit UUID in the application layer. Useful when
you need globally unique identifiers across databases, before an INSERT.

guid — Uses a globally unique identifier produced by the database, before an INSERT.

To summarize, our recommendations on identifier generator strategies are as follows:
- In general, we prefer pre-insert generation strategies that produce identifier values independently before INSERT.
- Use enhanced-sequence, which uses a native database sequence when supported and otherwise falls back 
to an extra database table with a single column and row, emulating a sequence.

Class-level options:
- Naming defaults and strategies
- Dynamic SQL generation
- Entity mutability

From time to time, especially in legacy databases, you’ll encounter identifiers with
strange characters or whitespace, or wish to force case sensitivity, or is a reserved keyword.

Hibernate 5 knows the reserved keywords of your DBMS through the configured
database dialect. Hibernate 5 can automatically put quotes around such strings when
generating SQL. You can enable this automatic quoting with 
hibernate.auto_quote_keyword=true in your persistence unit configuration.

delimited identifiers
@Table(name = "\"USER\"")

You should consider renaming tables or columns with reserved keyword names
whenever possible. Ad hoc SQL queries are difficult to write in an SQL console.

PhysicalNamingStrategy interface;
it offers methods for custom naming of columns, sequences, and other artifacts.
You have to enable the naming-strategy implementation in persistence.xml
<property name="hibernate.physical_naming_strategy" value="com.igor.setup.IgorNamingStrategy" />

A second option for naming customization is ImplicitNamingStrategy. Whereas the physical naming 
strategy acts at the lowest level, when schema artifact names are ultimately produced, 
the implicit-naming strategy is called before. If you map an entity class and don’t have an 
@Table annotation with an explicit name, the implicit-naming strategy implementation is asked 
what the table name should be. This is based on factors such as the entity name and class name. 
Hibernate ships with several strategies to implement legacy- or JPA-compliant default names. 
The default strategy is ImplicitNamingStrategyJpaCompliantImpl.

You can use short class names without a package prefix in JPA query strings.
If you add another Item class in a different package, you should rename one of them for JPA.
Of course, you can always use fully qualified long names with the package prefix.

By default, Hibernate creates SQL statements for each persistent class when the persistence
unit is created, on startup. These statements are simple create, read, update,
and delete (CRUD) operations for reading a single row, deleting a row, and so on. It’s
cheaper to store these in memory up front, instead of generating SQL strings every
time such a simple query has to be executed at runtime. In addition, prepared statement
caching at the JDBC level is much more efficient if there are fewer statements.

Generated SQL statement updates all columns, and if the value of a particular column isn’t 
modified, the statement sets it to its old value.

In some situations, such as a legacy table with hundreds of columns where the SQL
statements will be large for even the simplest operations (say, only one column needs
updating), you should disable this startup SQL generation and switch to dynamic statements
generated at runtime. An extremely large number of entities can also impact
startup time, because Hibernate has to generate all SQL statements for CRUD up front.
Memory consumption for this query statement cache will also be high if a dozen statements
must be cached for thousands of entities. This can be an issue in virtual environments
with memory limitations, or on low-power devices.

@org.hibernate.annotations.DynamicInsert
@org.hibernate.annotations.DynamicUpdate

By enabling dynamic insertion and updates, you tell Hibernate to produce the SQL
strings when needed, not up front. The UPDATE will only contain columns with
updated values, and the INSERT will only contain non-nullable columns.

@Immutable
Instances of a particular class may be immutable. For example, a Bid made for an item 
is immutable. Hence, Hibernate never needs to execute UPDATE statements on the BID table. 
Hibernate can also make a few other optimizations, such as avoiding dirty checking.
Can be applied on the class, field, or collections. Prefer @Column(updatable = false)
Can't make final fields. 

Hibernate doesn’t flush automatically before a find() operation — only before a Query is executed, if necessary.
